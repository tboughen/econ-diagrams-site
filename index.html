<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Microeconomics - Supply and Demand</title>
  <style>
    body { margin:0; font-family:Arial,sans-serif; user-select:none; display:flex; flex-direction:column; height:100vh; }
    nav { background:#333; color:#fff; padding:10px; text-align:center; }
    #main-container { flex:1; display:flex; overflow:hidden; }
    #sidebar { width:200px; background:#f5f5f5; border-right:1px solid #ccc; padding:20px; box-sizing:border-box; display:flex; flex-direction:column; gap:20px; }
    #sidebar h2 { margin:0; font-size:16px; text-align:center; }

    #buttonRow, #actionsRow { display:flex; flex-direction:row; justify-content:space-between; align-items:center; }
    #buttonRow button, #actionsRow button { flex:1; margin:0 5px; padding:10px 15px; font-size:16px; cursor:pointer; background:#ddd; color:#000; border:1px solid #999; border-radius:4px; transition:background-color .2s; }
    #buttonRow button:hover, #actionsRow button:hover { background:#ccc; }
    #buttonRow button:active, #actionsRow button:active { background:#bbb; }

    #marginToggle { text-align:center; padding:10px 0; cursor:pointer; background:#ddd; color:#000; border:1px solid #999; border-radius:4px; transition:background-color .2s; user-select:none; }
    #marginToggle:hover { background:#ccc; } #marginToggle:active { background:#bbb; } #marginToggle.active { background:#FFC300; }

    #curveToggle, #equilibriumToggle { display:flex; border:1px solid #999; border-radius:4px; overflow:hidden; }
    .curve-control-segment { flex:1; text-align:center; padding:10px 0; cursor:pointer; background:#ddd; color:#000; user-select:none; transition:background-color .2s; }
    .curve-control-segment:not(.active):hover { background:#ccc; }
    .curve-control-segment:not(.active):active { background:#bbb; }
    .curve-control-segment.active { background:#FFC300; }
    .curve-control-segment:not(:last-child) { border-right:1px solid #999; }

    .curve-row { display:flex; width:100%; gap:10px; box-sizing:border-box; }
    .curve-row button { flex:1 1 0; min-width:0; margin:0; padding:10px 15px; font-size:16px; cursor:pointer; background:#ddd; color:#000; border:1px solid #999; border-radius:4px; transition:background-color .2s; box-sizing:border-box; }
    .curve-row button:hover { background:#ccc; }
    .curve-row button:active { background:#bbb; }
    .curve-row button.active { background:#FFC300; }
    #curveButtons button.active, #demandButtons button.active { background:#FFC300; }

    .curve-row button .sub { font-size:.70em; vertical-align:-.20em; margin-left:0; }

    #canvas-area { flex:1; display:flex; flex-direction:column; margin:20px; gap:10px; }
    #canvas-container { display:flex; justify-content:center; align-items:center; }
    canvas { border:1px solid #ccc; }

    /* tiny breathing room for the feature panel */
    #feature-panel { display:block; padding-top:6px; }
    #sidebar h2 + #feature-panel { margin-top:-10px; }
    nav a { color:#fff; text-decoration:none; }
    nav a:hover { text-decoration:underline; }
  </style>
</head>
<body>
  <nav>
    <h1 style="display:inline;">Microeconomics - Supply and Demand</h1>
    <!-- Quick nav links -->
    <span style="margin-left:10px; font-size:14px;">
      · <a href="#supply-demand">S&amp;D</a>
      · <a href="#tax">Tax</a>
      · <a href="#subsidy">Subsidy</a>
      · <a href="#externalities">Externalities</a>
    </span>
  </nav>

  <div id="main-container">
    <div id="sidebar">
      <h2>Diagram Tools</h2>
      <div id="buttonRow">
        <button id="btnLarger" title="Increase text/line size">+</button>
        <button id="btnReset" title="Reset text/line size">⟲</button>
        <button id="btnSmaller" title="Decrease text/line size">–</button>
      </div>
      <div id="marginToggle" title="Toggle inner margins">Margin</div>

      <h2>History & Reset</h2>
      <div id="actionsRow">
        <button id="btnUndo" title="Undo">↶</button>
        <button id="btnRedo" title="Redo">↷</button>
        <button id="btnResetActions" title="Reset curves & price">⟲</button>
      </div>

      <h2>Curve Control</h2>
      <div id="curveToggle">
        <div id="toggleShifts" class="curve-control-segment active">Shifts</div>
        <div id="toggleElasticity" class="curve-control-segment">Elasticity</div>
      </div>

      <!-- Demand ABOVE Supply, identical widths -->
      <div id="demandButtons" class="curve-row">
        <button id="btnD1" aria-label="D 1">D<span class="sub">1</span></button>
        <button id="btnD2" aria-label="D 2">D<span class="sub">2</span></button>
        <button id="btnD3" aria-label="D 3">D<span class="sub">3</span></button>
      </div>
      <div id="curveButtons" class="curve-row">
        <button id="btnS1" aria-label="S 1">S<span class="sub">1</span></button>
        <button id="btnS2" aria-label="S 2">S<span class="sub">2</span></button>
        <button id="btnS3" aria-label="S 3">S<span class="sub">3</span></button>
      </div>

      <h2>Equilibrium Control</h2>
      <div id="equilibriumToggle">
        <div id="toggleEquilibrium" class="curve-control-segment active">Equilibrium</div>
        <div id="toggleDisequilibrium" class="curve-control-segment">Disequilibrium</div>
      </div>

      <!-- Feature slot lives INSIDE the sidebar -->
      <h2>Feature</h2>
      <div id="feature-panel"></div>
    </div>

    <div id="canvas-area">
      <div id="canvas-container">
        <canvas id="diagram" width="700" height="700"></canvas>
      </div>
    </div>
  </div>

  <script type="module">
    import { getFeature } from './src/app/features.js';
    import { startRouter, onRoute } from './src/app/router.js';

    /* Core helpers */
    import { clamp, isPointWithinBoundaries, getLineSegmentWithinBounds, computeIntersection } from './src/core/geometry.js';
    import { splitBaseSub } from './src/core/labels.js';
    import { computeBraceRadii, planUnderbrace4QuartersAnchored } from './src/core/brace.js';

    /* State (B2) */
    import { createHistoryStore } from './src/state/history.js';
    import { reducer, initialState as baseInitial } from './src/state/reducer.js';
    import { visibleSupply, visibleDemand, allCurves } from './src/state/selectors.js';

    let currentFeature = null;

    // --- helper to execute a brace plan from core/brace.js ---
    function executeBracePlan(ctx, plan) {
      const { style, ops } = plan;
      ctx.save();
      ctx.setLineDash([]);
      ctx.strokeStyle = style.color;
      ctx.lineWidth = style.lineWidth;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      for (const op of ops) {
        if (op.op === 'line') {
          ctx.beginPath(); ctx.moveTo(op.from.x, op.from.y); ctx.lineTo(op.to.x, op.to.y); ctx.stroke();
        } else if (op.op === 'quad') {
          ctx.beginPath(); ctx.moveTo(op.from.x, op.from.y); ctx.quadraticCurveTo(op.ctrl.x, op.ctrl.y, op.to.x, op.to.y); ctx.stroke();
        } else if (op.op === 'arc') {
          ctx.beginPath(); ctx.arc(op.cx, op.cy, op.r, op.fromAngle, op.toAngle, op.ccw); ctx.stroke();
        }
      }
      ctx.restore();
    }

    // ---- helpers bundle passed to features ----
    const helpers = {
      getOuterBoundaries,
      getEffectiveBoundaries,
      computeIntersection,
      computeBraceRadii,
      planUnderbrace4QuartersAnchored,
      executeBracePlan,
      getLineSegmentWithinBounds,
      selectors: { visibleSupply, visibleDemand, allCurves },
      getTextSize: () => store.getState().textSize,
      lineW: () => store.getState().textSize / 5,
    };

    // ================== APP CODE USING PURE STATE ==================

    // canvas + geometry
    const canvas = document.getElementById('diagram');
    const ctx = canvas.getContext('2d');

    const baseMargin = 70, diagramWidth = 600;
    const DIAGRAM_HEIGHT = 600;
    const EXTRA_LEFT = 40;
    const EXTRA_BOTTOM = 40;

    function getOuterBoundaries() {
      const V_SHIFT = (canvas.height - DIAGRAM_HEIGHT) - EXTRA_BOTTOM;
      const yTopFixed    = baseMargin + V_SHIFT;
      const yBottomFixed = yTopFixed + (DIAGRAM_HEIGHT - 2*baseMargin); // 460px axis
      return {
        xLeft:  baseMargin + 50 + EXTRA_LEFT,
        xRight: (diagramWidth - baseMargin + 50) + EXTRA_LEFT,
        yTop:   yTopFixed,
        yBottom: yBottomFixed
      };
    }

    function getEffectiveBoundaries() {
      const o = getOuterBoundaries();
      const extra = store.getState().marginEnabled ? 50 : 0;
      return { xLeft:o.xLeft+extra, xRight:o.xRight-extra, yTop:o.yTop+extra, yBottom:o.yBottom-extra };
    }

    // text sizing derived from state
    const lineW = () => store.getState().textSize / 5;

    // --- INITIAL STATE SEED (curves match your previous numbers)
    const ob = getOuterBoundaries();
    const seed = {
      ...baseInitial,
      textSize: 20,
      curves: [
        { id:'S1', kind:'supply',  slope:-1, intercept:(ob.yBottom+ob.xLeft),     label:'S1', color:'#000', visible:true  },
        { id:'S2', kind:'supply',  slope:-1, intercept:(ob.yBottom+ob.xLeft+100), label:'S2', color:'#000', visible:false },
        { id:'S3', kind:'supply',  slope:-1, intercept:(ob.yBottom+ob.xLeft+200), label:'S3', color:'#000', visible:false },
        { id:'D1', kind:'demand',  slope: 1, intercept:(ob.yTop -ob.xLeft),       label:'D1', color:'#000', visible:true  },
        { id:'D2', kind:'demand',  slope: 1, intercept:(ob.yTop -ob.xLeft-100),   label:'D2', color:'#000', visible:false },
        { id:'D3', kind:'demand',  slope: 1, intercept:(ob.yTop -ob.xLeft-200),   label:'D3', color:'#000', visible:false }
      ],
      eqMode: 'equilibrium',
      priceY: null,
      marginEnabled: false
    };

    const store = createHistoryStore(reducer, seed);

    // utilities that depend on state
    const getTextSize = () => store.getState().textSize;
    const isDiseq = () => store.getState().eqMode === 'disequilibrium';

    // --- drawing helpers that read state
    const SUBSCRIPT_DEFAULT = { subScale:.70, dropEm:.20, kernPx:-.5, color:'#000' };
    const SUBSCRIPT_Q       = { subScale:.70, dropEm:.26, kernPx:-.5, color:'#000' };
    const SUBSCRIPT_CURVE   = { subScale:.70, dropEm:.20, kernPx:-.5, color:'#000' };

    function drawWithSubscript(main, sub, x, y, {
      align='left', baseline='alphabetic', subScale=.70, dropEm=.20, kernPx=0, color='#000'
    }={}) {
      const textSize = getTextSize();
      const mainSize=textSize, subSize=Math.round(textSize*subScale), drop=Math.round(textSize*dropEm);
      ctx.save(); ctx.textBaseline=baseline;

      ctx.font = `${mainSize}px Arial`; const wMain=ctx.measureText(main).width;
      ctx.font = `${subSize}px Arial`;  const wSub =ctx.measureText(sub).width;
      const total = wMain + kernPx + wSub;

      let startX=x;
      if(align==='center') startX=x-total/2;
      else if(align==='right') startX=x-total;

      ctx.font = `${mainSize}px Arial`; ctx.fillStyle=color; ctx.fillText(main,startX,y);
      ctx.font = `${subSize}px Arial`;  ctx.fillStyle=color; ctx.fillText(sub, startX+wMain+kernPx, y+drop);
      ctx.restore();
    }

    function useEquilibriumDash(){
      ctx.setLineDash([15,15]); ctx.strokeStyle='gray'; ctx.lineWidth=lineW();
    }

    // --- equilibrium computation from state
    function getEquilibriumPoint(s) {
      const eff = getEffectiveBoundaries();
      const S = visibleSupply(s), D = visibleDemand(s);
      if (!S || !D) return null;
      const p = computeIntersection(S.slope, S.intercept, D.slope, D.intercept);
      return (p && isPointWithinBoundaries(p, eff)) ? p : null;
    }

    function drawAxes(){
      const o=getOuterBoundaries(); const textSize = getTextSize();
      ctx.save(); ctx.strokeStyle='black'; ctx.lineWidth=lineW();
      ctx.beginPath(); ctx.moveTo(o.xLeft,o.yBottom); ctx.lineTo(o.xRight,o.yBottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(o.xLeft,o.yBottom); ctx.lineTo(o.xLeft,o.yTop); ctx.stroke();
      ctx.font=`${textSize}px Arial`; ctx.fillStyle='black';
      ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText('Price', o.xLeft-10, o.yTop);
      ctx.textAlign='right'; ctx.textBaseline='top'; ctx.fillText('Quantity', o.xRight, o.yBottom+10);
      ctx.restore();
    }

    function renderEquilibrium(){
      const s = store.getState();
      const eq = getEquilibriumPoint(s); if(!eq) return;
      const o=getOuterBoundaries(); const eff=getEffectiveBoundaries();

      ctx.save(); ctx.setLineDash([15,15]); ctx.strokeStyle='gray'; ctx.lineWidth=lineW();
      ctx.beginPath(); ctx.moveTo(eq.x,eq.y); ctx.lineTo(eq.x,o.yBottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(eq.x,eq.y); ctx.lineTo(o.xLeft,eq.y); ctx.stroke();
      ctx.restore();

      ctx.save(); ctx.beginPath(); ctx.rect(eff.xLeft,eff.yTop, eff.xRight-eff.xLeft, eff.yBottom-eff.yTop); ctx.clip();
      ctx.fillStyle='black'; ctx.beginPath(); ctx.arc(eq.x,eq.y,5,0,2*Math.PI); ctx.fill(); ctx.restore();

      drawWithSubscript('P','1', o.xLeft-15, eq.y, {align:'right', baseline:'middle', ...SUBSCRIPT_DEFAULT});
      drawWithSubscript('Q','1', eq.x, o.yBottom+15, {align:'center', baseline:'top', ...SUBSCRIPT_Q});
    }

    function renderLabels(eff, drawnSegById){
      allCurves(store.getState()).forEach(c=>{
        if(!c.visible) return;
        const seg = drawnSegById.get(c.id);
        if(!seg) return;
        const end=(seg[0].x<seg[1].x)?seg[1]:seg[0];
        const {base,sub}=splitBaseSub(c.label);
        drawWithSubscript(base, sub, end.x+10, end.y-10, {align:'left', baseline:'bottom', ...SUBSCRIPT_CURVE});
      });
    }

    function computeQxAtPrice(y, curve){ if(!curve||!curve.visible||Math.abs(curve.slope)<1e-9) return null; return (y - curve.intercept)/curve.slope; }

    function renderPairEquilibriumForSub(S, D, pSubNum, qSubNum){
      const eff=getEffectiveBoundaries(), o=getOuterBoundaries();
      const eq=computeIntersection(S.slope,S.intercept,D.slope,D.intercept);
      if(!eq||!isPointWithinBoundaries(eq,eff)) return;

      ctx.save(); useEquilibriumDash();
      ctx.beginPath(); ctx.moveTo(eq.x,eq.y); ctx.lineTo(eq.x,o.yBottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(eq.x,eq.y); ctx.lineTo(o.xLeft,eq.y);   ctx.stroke();
      ctx.restore();

      ctx.save(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(eq.x,eq.y,4,0,2*Math.PI); ctx.fill(); ctx.restore();

      drawWithSubscript('P', String(pSubNum), o.xLeft-15, eq.y, {align:'right', baseline:'middle', ...SUBSCRIPT_DEFAULT});
      drawWithSubscript('Q', String(qSubNum), eq.x, o.yBottom+15, {align:'center', baseline:'top', ...SUBSCRIPT_Q});
    }

    function inBoundsPair(S,D){
      const eff=getEffectiveBoundaries();
      const eq=computeIntersection(S.slope,S.intercept,D.slope,D.intercept);
      return eq && isPointWithinBoundaries(eq,eff);
    }

    function renderP2Q2Auto(){
      const s = store.getState();
      const S = { S1: s.curves.find(c=>c.id==='S1'), S2: s.curves.find(c=>c.id==='S2') , S3: s.curves.find(c=>c.id==='S3') };
      const D = { D1: s.curves.find(c=>c.id==='D1'), D2: s.curves.find(c=>c.id==='D2') , D3: s.curves.find(c=>c.id==='D3') };
      const cand=[[S.S2,D.D2],[S.S1,D.D2],[S.S2,D.D1]];
      for(const [a,b] of cand){ if(a&&b&&a.visible&&b.visible&&inBoundsPair(a,b)){ renderPairEquilibriumForSub(a,b,2,2); return; } }
    }

    function choosePairForP3(){
      const s = store.getState();
      const S = { S1: s.curves.find(c=>c.id==='S1'), S2: s.curves.find(c=>c.id==='S2') , S3: s.curves.find(c=>c.id==='S3') };
      const D = { D1: s.curves.find(c=>c.id==='D1'), D2: s.curves.find(c=>c.id==='D2') , D3: s.curves.find(c=>c.id==='D3') };
      const cand=[[S.S3,D.D3],[S.S3,D.D2],[S.S2,D.D3],[S.S3,D.D1],[S.S1,D.D3]];
      for(const [a,b] of cand){ if(a&&b&&a.visible&&b.visible&&inBoundsPair(a,b)) return {s:a,d:b}; }
      return null;
    }
    function renderP3Q3Auto(){ const sel=choosePairForP3(); if(!sel) return; renderPairEquilibriumForSub(sel.s, sel.d, 3, 3); }

    // --- Disequilibrium overlay (uses state eqMode/priceY + brace planner)
    const priceDrag = { dragging:false, hover:false, handleRadius:7 };

    function renderPriceOverlay(show){
      if(!isDiseq()) return;

      const state = store.getState();
      let yP = state.priceY;
      const eq = getEquilibriumPoint(state);
      if(yP == null && eq) yP = eq.y;
      if(yP == null) return;

      const eff=getEffectiveBoundaries(), o=getOuterBoundaries();
      const S=visibleSupply(state), D=visibleDemand(state);
      if(!S||!D) return;

      yP = clamp(yP, eff.yTop, eff.yBottom);

      const xS=computeQxAtPrice(yP,S), xD=computeQxAtPrice(yP,D);
      const valid=(x)=>x!=null && x>=eff.xLeft && x<=eff.xRight; if(!valid(xS)||!valid(xD)) return;

      const leftAttach = Math.min(xS,xD);
      const rightAttach= Math.max(xS,xD);

      // Handle
      ctx.save();
      const hover = priceDrag.hover || priceDrag.dragging;
      ctx.fillStyle = '#555';
      ctx.beginPath(); ctx.arc(o.xLeft, yP, priceDrag.handleRadius, 0, 2*Math.PI); ctx.fill();
      ctx.strokeStyle = '#333';
      ctx.lineWidth   = hover ? 2.5 : 1.5;
      ctx.stroke();
      ctx.restore();

      if(!show) return;

      // Horizontal price dash
      ctx.save(); useEquilibriumDash(); ctx.lineCap='butt';
      ctx.beginPath(); ctx.moveTo(o.xLeft, yP); ctx.lineTo(rightAttach, yP); ctx.stroke();
      ctx.restore();

      drawWithSubscript('P','1', o.xLeft-15, yP, {align:'right', baseline:'middle', ...SUBSCRIPT_DEFAULT});

      // Vertical Q guides
      ctx.save(); useEquilibriumDash();
      ctx.beginPath(); ctx.moveTo(xS, yP); ctx.lineTo(xS, o.yBottom); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xD, yP); ctx.lineTo(xD, o.yBottom); ctx.stroke();
      ctx.restore();

      drawWithSubscript('Q','D', xD, o.yBottom+15, {align:'center', baseline:'top', ...SUBSCRIPT_Q});
      drawWithSubscript('Q','S', xS, o.yBottom+15, {align:'center', baseline:'top', ...SUBSCRIPT_Q});

      // Shading
      if(Math.abs(xS-xD)>1e-3){
        ctx.save(); ctx.globalAlpha=.15; ctx.fillStyle=(xS>xD)?'#2a9d8f':'#d62828';
        ctx.fillRect(leftAttach, yP, rightAttach-leftAttach, o.yBottom-yP); ctx.restore();
      }

      // Brace baseline
      const textSize = getTextSize();
      const qLabelTop = o.yBottom + 15;
      const qLabelH   = textSize;
      const gapBelow  = Math.max(6, textSize*0.20);
      const baselineY = qLabelTop + qLabelH + gapBelow;

      const shortage = (xD > xS);
      const braceColor = shortage ? '#d62828' : '#2a9d8f';

      const L = rightAttach - leftAttach;
      if (L >= 10) {
        const radii = computeBraceRadii(L);
        const clearance = (canvas.height - 6) - baselineY;
        const needMax = Math.max(radii.rEnd, radii.rMid);
        if (clearance < needMax) {
          const k = Math.max(0, clearance) / (needMax || 1);
          radii.rEnd *= k; radii.rMid *= k;
        }
        const plan = planUnderbrace4QuartersAnchored(leftAttach, rightAttach, baselineY, {
          color: braceColor,
          lineWidth: Math.max(1.5, textSize/5.5),
          radii
        });
        if (plan) executeBracePlan(ctx, plan);

        // Caption
        const midX = (leftAttach + rightAttach)/2;
        const label = shortage ? 'Shortage' : 'Surplus';
        const labelSize = Math.max(10, Math.round(textSize * 0.85));
        const delta = 0.5 * radii.rEnd;
        const yTextRaw = (baselineY + delta) + radii.rMid + Math.max(6, textSize*0.25);
        const yText = Math.min(canvas.height - 6, yTextRaw);
        ctx.save(); ctx.setLineDash([]); ctx.fillStyle = braceColor;
        ctx.font = `${labelSize}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'top';
        ctx.fillText(label, midX, yText);
        ctx.restore();
      }
    }

    // --- main render
    function renderDiagram(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawAxes();
      const eff=getEffectiveBoundaries();

      // draw curves directly from state
      const drawnSegById = new Map();
      allCurves(store.getState()).forEach(c=>{
        if(!c.visible) return;
        const seg=getLineSegmentWithinBounds(c.slope,c.intercept,eff.xLeft,eff.xRight,eff.yTop,eff.yBottom);
        if(!seg) return;
        drawnSegById.set(c.id, seg);
        ctx.strokeStyle=c.color; ctx.lineWidth=lineW();
        ctx.beginPath(); ctx.moveTo(seg[0].x,seg[0].y); ctx.lineTo(seg[1].x,seg[1].y); ctx.stroke();
      });

      if(store.getState().eqMode==='equilibrium'){ renderEquilibrium(); renderP2Q2Auto(); renderP3Q3Auto(); }
      if(isDiseq()){ renderPriceOverlay(priceDrag.dragging || priceDrag.hover); }

      renderLabels(eff, drawnSegById);

      /* ---- C2 Step 6: feature overlay hook ---- */
      if (currentFeature?.overlay) {
        currentFeature.overlay(ctx, store, helpers);
      }
    }

    // --- interaction state
    let mode='shift', currentId=null, dragging=false, rotating=false, lastMouseX=0, initialMouseX=0, rotationPivot=null, initialAngle=null;

    // buttons: text size
    document.getElementById('btnLarger').addEventListener('click', ()=>{ 
      store.dispatch({ type:'setTextSize', value: getTextSize()+2 }); renderDiagram();
    });
    document.getElementById('btnSmaller').addEventListener('click', ()=>{ 
      store.dispatch({ type:'setTextSize', value: Math.max(10, getTextSize()-2) }); renderDiagram();
    });
    document.getElementById('btnReset').addEventListener('click', ()=>{ 
      store.dispatch({ type:'setTextSize', value: 20 }); renderDiagram();
    });

    // margin toggle
    const marginToggle=document.getElementById('marginToggle');
    marginToggle.addEventListener('click', ()=>{ 
      store.dispatch({ type:'toggleMargin' }); 
      marginToggle.classList.toggle('active', store.getState().marginEnabled); 
      renderDiagram(); 
    });

    // undo/redo/reset
    const btnUndo=document.getElementById('btnUndo'), btnRedo=document.getElementById('btnRedo'), btnResetActions=document.getElementById('btnResetActions');
    btnUndo.addEventListener('click', ()=>{ store.undo(); renderDiagram(); });
    btnRedo.addEventListener('click', ()=>{ store.redo(); renderDiagram(); });
    btnResetActions.addEventListener('click', ()=>{
      store.reset(seed);
      updateButtonStates(); setEqMode('equilibrium'); renderDiagram();
    });

    // mode toggles
    const toggleShifts=document.getElementById('toggleShifts'), toggleElasticity=document.getElementById('toggleElasticity');
    toggleShifts.addEventListener('click', ()=>{ mode='shift'; toggleShifts.classList.add('active'); toggleElasticity.classList.remove('active'); });
    toggleElasticity.addEventListener('click', ()=>{ mode='rotate'; toggleElasticity.classList.add('active'); toggleShifts.classList.remove('active'); });

    const toggleEquilibrium=document.getElementById('toggleEquilibrium');
    const toggleDisequilibrium=document.getElementById('toggleDisequilibrium');

    function setEqMode(newMode){
      store.dispatch({ type:'setEqMode', mode:newMode });
      toggleEquilibrium.classList.toggle('active',newMode==='equilibrium');
      toggleDisequilibrium.classList.toggle('active',newMode==='disequilibrium');
      if(newMode==='equilibrium'){
        priceDrag.dragging=false;
      }else{
        const s = store.getState();
        if(s.priceY == null){
          const eq = getEquilibriumPoint(s);
          const fallback = getEffectiveBoundaries().yTop + 40;
          store.dispatch({ type:'setPriceY', y: eq ? eq.y : fallback });
        }
      }
      renderDiagram();
    }
    toggleEquilibrium.addEventListener('click', ()=>setEqMode('equilibrium'));
    toggleDisequilibrium.addEventListener('click', ()=>setEqMode('disequilibrium'));

    // helpers for finding nearest curve
    const distToCurve = (c, px, py) => Math.abs(c.slope*px - py + c.intercept)/Math.sqrt(c.slope**2+1);

    function nearestCurveIdAt(m){
      let cand=null, min=Infinity;
      allCurves(store.getState()).forEach(c=>{
        const d=distToCurve(c, m.x, m.y);
        if(d<min){min=d; cand=c;}
      });
      return (min<5 && cand) ? cand.id : null;
    }

    // price handle proximity
    function isNearPriceHandle(x,y){ if(!isDiseq()) return false; const o=getOuterBoundaries(); const yP=store.getState().priceY ?? y;
      const dx=x-o.xLeft, dy=y-yP; return Math.hypot(dx,dy) <= (priceDrag.handleRadius+4); }
    function isNearPriceLine(x,y){ if(!isDiseq()) return false; const yP=store.getState().priceY; if(yP==null) return false; return Math.abs(y-yP) < 6; }

    // mouse events
    const canvasEl = canvas;
    canvasEl.addEventListener('mousedown',(e)=>{
      const r=canvasEl.getBoundingClientRect(); const m={x:e.clientX-r.left, y:e.clientY-r.top};
      if(isNearPriceHandle(m.x,m.y) || isNearPriceLine(m.x,m.y)){
        priceDrag.dragging=true;
        store.dispatch({ type:'setPriceY', y: clamp(m.y, getEffectiveBoundaries().yTop, getEffectiveBoundaries().yBottom) });
        renderDiagram(); return;
      }
      const id = nearestCurveIdAt(m);
      if(!id) return;

      if(mode==='shift'){ dragging=true; lastMouseX=m.x; currentId=id; }
      else{
        rotating=true; initialMouseX=m.x; currentId=id;
        // choose pivot
        const s=store.getState();
        let pivot=null;
        const me = s.curves.find(c=>c.id===id);
        const other = (me.kind==='supply') ? visibleDemand(s) : visibleSupply(s);
        if(other){
          const p=computeIntersection(me.slope,me.intercept, other.slope,other.intercept);
          if(p && isPointWithinBoundaries(p,getEffectiveBoundaries())) pivot=p;
        }
        const eq = getEquilibriumPoint(s); if(!pivot && eq) pivot=eq;
        if(!pivot){
          const eff=getEffectiveBoundaries();
          const seg=getLineSegmentWithinBounds(me.slope,me.intercept,eff.xLeft,eff.xRight,eff.yTop,eff.yBottom);
          pivot = seg ? {x:(seg[0].x+seg[1].x)/2, y:(seg[0].y+seg[1].y)/2} : {x:(eff.xLeft+eff.xRight)/2, y:(eff.yTop+eff.yBottom)/2};
        }
        rotationPivot=pivot; initialAngle=Math.atan(me.slope);
      }
    });

    canvasEl.addEventListener('mousemove',(e)=>{
      const r=canvasEl.getBoundingClientRect(); const m={x:e.clientX-r.left, y:e.clientY-r.top};
      priceDrag.hover = isNearPriceHandle(m.x,m.y) || isNearPriceLine(m.x,m.y);
      canvasEl.style.cursor = (priceDrag.hover||priceDrag.dragging) ? 'ns-resize' : (dragging||rotating ? 'grabbing' : 'default');

      if(priceDrag.dragging){
        store.dispatch({ type:'setPriceY', y: clamp(m.y, getEffectiveBoundaries().yTop, getEffectiveBoundaries().yBottom) });
        renderDiagram(); return;
      }

      if(dragging && mode==='shift' && currentId){
        const dx=m.x-lastMouseX; lastMouseX=m.x;
        const before = store.getState();
        store.dispatch({ type:'shiftCurve', id: currentId, dx });
        if(!getEquilibriumPoint(store.getState())) { store.undo(); }
        renderDiagram();
      } else if(rotating && mode==='rotate' && currentId && rotationPivot){
        const dx=m.x-initialMouseX;
        const me = store.getState().curves.find(c=>c.id===currentId);
        const newA=(m.y>rotationPivot.y)?(initialAngle - dx*0.005):(initialAngle + dx*0.005);
        store.dispatch({ type:'rotateCurve', id: currentId, angle:newA, pivot:rotationPivot });
        if(!getEquilibriumPoint(store.getState())) { store.undo(); }
        renderDiagram();
      }
    });

    function stopDrags(){ dragging=false; rotating=false; currentId=null; if(priceDrag.dragging){ priceDrag.dragging=false; } renderDiagram(); }
    canvasEl.addEventListener('mouseup',stopDrags);
    canvasEl.addEventListener('mouseleave',stopDrags);

    // curve toggle buttons
    const btnS1=document.getElementById('btnS1'), btnS2=document.getElementById('btnS2'), btnS3=document.getElementById('btnS3');
    const btnD1=document.getElementById('btnD1'), btnD2=document.getElementById('btnD2'), btnD3=document.getElementById('btnD3');

    function updateButtonStates(){
      const s = store.getState();
      const v = id => (s.curves.find(c=>c.id===id)||{}).visible;
      btnS1.classList.toggle('active',v('S1')); btnS2.classList.toggle('active',v('S2')); btnS3.classList.toggle('active',v('S3'));
      btnD1.classList.toggle('active',v('D1')); btnD2.classList.toggle('active',v('D2')); btnD3.classList.toggle('active',v('D3'));
      marginToggle.classList.toggle('active', s.marginEnabled);
    }
    function toggleCurve(id, btn){ store.dispatch({ type:'toggleCurve', id }); btn.classList.toggle('active'); renderDiagram(); }
    btnS1.addEventListener('click',()=>toggleCurve('S1',btnS1));
    btnS2.addEventListener('click',()=>toggleCurve('S2',btnS2));
    btnS3.addEventListener('click',()=>toggleCurve('S3',btnS3));
    btnD1.addEventListener('click',()=>toggleCurve('D1',btnD1));
    btnD2.addEventListener('click',()=>toggleCurve('D2',btnD2));
    btnD3.addEventListener('click',()=>toggleCurve('D3',btnD3));

    // --- feature panel mount + routing
    function mountPanel(feature){
      const slot = document.getElementById('feature-panel');
      if (!slot) return;
      slot.innerHTML = '';
      if (feature?.panel) feature.panel(slot, store, helpers);
    }

    onRoute(route => {
      currentFeature = getFeature(route);
      const ob = getOuterBoundaries();
      store.reset(currentFeature.initialSeed(ob));
      mountPanel(currentFeature);
      updateButtonStates();
      renderDiagram();
    });

    // initial paint + start router once
    updateButtonStates();
    setEqMode('equilibrium');
    renderDiagram();
    startRouter();
  </script>
</body>
</html>
